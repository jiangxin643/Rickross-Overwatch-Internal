#include "../main_win.h"
#include "c_dx11.h"

#include "d3d11.h"
#include "dxgi.h"

c_dx11_render dx11_instance;
c_dx11_render* g_dx11 = &dx11_instance;

#define VERTEX_SIZE 8192
#define LINES_SIZE 8192
#define TEXT_POINTS_SIZE 65535

uint8_t s_pixel_shader_code[] = {
	0x44, 0x58, 0x42, 0x43, 0x71, 0xEE, 0xB8, 0x3B, 0xE2, 0x77, 0xF8, 0x55, 0x47, 0x8A, 0x89, 0xF3, 0x78, 0x2F, 0x06, 0xE9, 0x01, 0x00, 0x00, 0x00, 0xA0, 0x01, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0xE4, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFF, 0xFF, 0x00, 0x01, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4C, 0x53, 0x4C, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2E, 0x31, 0x00, 0x49, 0x53, 0x47, 0x4E, 0x28, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x43, 0x4F, 0x4C, 0x4F, 0x52, 0x00, 0xAB, 0xAB, 0x4F, 0x53, 0x47, 0x4E, 0x2C, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x53, 0x56, 0x5F, 0x54, 0x41, 0x52, 0x47, 0x45, 0x54, 0x00, 0xAB, 0xAB, 0x53, 0x48, 0x44, 0x52, 0x38, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x62, 0x10, 0x00, 0x03, 0xF2, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xF2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0xF2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x1E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

uint8_t s_vertex_shader_code[] {
	0x44, 0x58, 0x42, 0x43, 0x5F, 0x0B, 0x2C, 0x91, 0x23, 0xDA, 0xE8, 0xAE, 0x94, 0x4B, 0x71, 0xFD, 0x64, 0x11, 0xB9, 0x13, 0x01, 0x00, 0x00, 0x00, 0x10, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x24, 0x01, 0x00, 0x00, 0x94, 0x01, 0x00, 0x00, 0x52, 0x44, 0x45, 0x46, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFE, 0xFF, 0x00, 0x01, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x28, 0x52, 0x29, 0x20, 0x48, 0x4C, 0x53, 0x4C, 0x20, 0x53, 0x68, 0x61, 0x64, 0x65, 0x72, 0x20, 0x43, 0x6F, 0x6D, 0x70, 0x69, 0x6C, 0x65, 0x72, 0x20, 0x31, 0x30, 0x2E, 0x31, 0x00, 0x49, 0x53, 0x47, 0x4E, 0x48, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x43, 0x4F, 0x4C, 0x4F, 0x52, 0x00, 0x50, 0x4F, 0x53, 0x49, 0x54, 0x49, 0x4F, 0x4E, 0x00, 0xAB, 0x4F, 0x53, 0x47, 0x4E, 0x4C, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x43, 0x4F, 0x4C, 0x4F, 0x52, 0x00, 0x53, 0x56, 0x5F, 0x50, 0x4F, 0x53, 0x49, 0x54, 0x49, 0x4F, 0x4E, 0x00, 0xAB, 0xAB, 0x53, 0x48, 0x44, 0x52, 0x68, 0x00, 0x00, 0x00, 0x40, 0x00, 0x01, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x03, 0xF2, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x00, 0x00, 0x03, 0xF2, 0x10, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x03, 0xF2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x04, 0xF2, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0xF2, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0x1E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x05, 0xF2, 0x20, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x46, 0x1E, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x01, 0x53, 0x54, 0x41, 0x54, 0x74, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

bool c_dx11_render::init() {
	if (_init)
		return !_failed;
	
	_init = true;
	_failed = true;
	
	{
		HRESULT result = _swapchain->GetDevice(__uuidof(ID3D11Device), (void**)(&_device));
		if (result != S_OK) {
			BREAK();
			return false;
		}
		
		_device->GetImmediateContext(&_context);
		if (_context == NULL) {
			BREAK();
			return false;
		}
	}
	
	{
		ID3D11Texture2D* rt = 0;
		HRESULT result = _swapchain->GetBuffer(0, __uuidof(ID3D11Texture2D), &rt);
		if (result != S_OK) {
			BREAK();
			return false;
		}
		
		HRESULT result2 = _device->CreateRenderTargetView(rt, 0, &_render_target);
		if (result2 != S_OK) {
			BREAK();
			return false;
		}
		
		rt->Release();
	}
	
	{
		D3D11_INPUT_ELEMENT_DESC layout[] = {
			{"POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0},
			{"COLOR", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 8, D3D11_INPUT_PER_VERTEX_DATA, 0}
		};
		
		HRESULT result = _device->CreateInputLayout(layout, 2, s_vertex_shader_code, sizeof(s_vertex_shader_code), &_input);
		if (result != S_OK) {
			BREAK();
			return false;
		}
	}
	
	{
		D3D11_BUFFER_DESC buffer_desc = {};
		buffer_desc.Usage = D3D11_USAGE_DYNAMIC;
		buffer_desc.ByteWidth = VERTEX_SIZE * sizeof(DX11_Vertex);
		buffer_desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		buffer_desc.MiscFlags = 0;
		
		HRESULT result = _device->CreateBuffer(&buffer_desc, NULL, &_vertex_buffer);
		if (result != S_OK) {
			BREAK();
			return false;
		}
	}
	
	{
		D3D11_BUFFER_DESC buffer_desc = {};
		buffer_desc.Usage = D3D11_USAGE_DYNAMIC;
		buffer_desc.ByteWidth = LINES_SIZE * sizeof(DX11_Vertex);
		buffer_desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		buffer_desc.MiscFlags = 0;
		
		HRESULT result = _device->CreateBuffer(&buffer_desc, NULL, &_lines_buffer);
		if (result != S_OK) {
			BREAK();
			return false;
		}
	}
	
	{
		D3D11_BUFFER_DESC buffer_desc = {};
		buffer_desc.Usage = D3D11_USAGE_DYNAMIC;
		buffer_desc.ByteWidth = TEXT_POINTS_SIZE * sizeof(DX11_Vertex);
		buffer_desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
		buffer_desc.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;
		buffer_desc.MiscFlags = 0;
		
		HRESULT result = _device->CreateBuffer(&buffer_desc, NULL, &_text_buffer);
		if (result != S_OK) {
			BREAK();
			return false;
		}
	}
	
	{
		D3D11_RASTERIZER_DESC rasterizer_desc = {};
		rasterizer_desc.FillMode = D3D11_FILL_SOLID;
		rasterizer_desc.CullMode = D3D11_CULL_NONE;
		rasterizer_desc.DepthBias = 0x7fffffff;
		
		HRESULT result = _device->CreateRasterizerState(&rasterizer_desc, &_rasterizer_state);
		if (result != S_OK) {
			BREAK();
			return false;
		}
	}
	
	{
		HRESULT result = _device->CreatePixelShader(s_pixel_shader_code, sizeof(s_pixel_shader_code), NULL, &_pixel_shader);
		if (result != S_OK) {
			BREAK();
			return false;
		}
	}
	
	{
		HRESULT result = _device->CreateVertexShader(s_vertex_shader_code, sizeof(s_vertex_shader_code), NULL, &_vertex_shader);
		if (result != S_OK) {
			BREAK();
			return false;
		}
	}
	
	_failed = false;
	
	return true;
}

bool c_dx11_render::ready() {
	return _init && !_failed;
}

HWND c_dx11_render::get_window() {
	DXGI_SWAP_CHAIN_DESC desc;
	if (_swapchain->GetDesc(&desc) != S_OK)
		return NULL;
	
	return desc.OutputWindow;
}

void c_dx11_render::store_context() {
	_old_viewport_count = 16;
	_old_scissor_rects_count = 16;
	
	_context->IAGetInputLayout(&_old_input);
	_context->IAGetVertexBuffers(0, 1, &_old_vertex_buffer, &_old_stride, &_old_offset);
	_context->IAGetPrimitiveTopology((D3D11_PRIMITIVE_TOPOLOGY*)&_old_topology);
	
	_context->RSGetState(&_old_rasterizer_state);
	_context->RSGetViewports(&_old_viewport_count, (D3D11_VIEWPORT*)_old_viewports);
	_context->RSGetScissorRects(&_old_scissor_rects_count, (D3D11_RECT*)_old_scissor_rects);
	
	_context->PSGetShader(&_old_pixel_shader, 0, 0);
	_context->VSGetShader(&_old_vertex_shader, 0, 0);
	_context->GSGetShader(&_old_geometry_shader, 0, 0);
	_context->HSGetShader(&_old_hull_shader, 0, 0);
	_context->DSGetShader(&_old_domain_shader, 0, 0);
	_context->CSGetShader(&_old_compute_shader, 0, 0);
	
	_context->OMGetBlendState(&_old_blend_state, _old_blend_factor, &_old_sample_mask);
}

void c_dx11_render::load_context() {
	_context->IASetInputLayout(_old_input);
	_context->IASetVertexBuffers(0, 1, &_old_vertex_buffer, &_old_stride, &_old_offset);
	_context->IASetPrimitiveTopology((D3D11_PRIMITIVE_TOPOLOGY)_old_topology);
	
	_context->RSSetState(_old_rasterizer_state);
	_context->RSSetViewports(_old_viewport_count, (D3D11_VIEWPORT*)_old_viewports);
	_context->RSSetScissorRects(_old_scissor_rects_count, (D3D11_RECT*)_old_scissor_rects);
	
	_context->PSSetShader(_old_pixel_shader, 0, 0);
	_context->VSSetShader(_old_vertex_shader, 0, 0);
	_context->GSSetShader(_old_geometry_shader, 0, 0);
	_context->HSSetShader(_old_hull_shader, 0, 0);
	_context->DSSetShader(_old_domain_shader, 0, 0);
	_context->CSSetShader(_old_compute_shader, 0, 0);
	
	_context->OMSetBlendState(_old_blend_state, _old_blend_factor, _old_sample_mask);
}

void c_dx11_render::start_render() {
	_context->OMSetRenderTargets(1, &_render_target, 0);
	
	_context->IASetInputLayout(_input);
	
	_context->PSSetShader(_pixel_shader, 0, 0);
	_context->VSSetShader(_vertex_shader, 0, 0);
	_context->GSSetShader(0, 0, 0);
	_context->HSSetShader(0, 0, 0);
	_context->DSSetShader(0, 0, 0);
	_context->CSSetShader(0, 0, 0);
	
	D3D11_RECT rect;
	rect.left = 0;
	rect.top = 0;
	rect.right = (LONG)_width;
	rect.bottom = (LONG)_height;
	_context->RSSetScissorRects(1, &rect);
	
	D3D11_VIEWPORT vp;
	vp.Width = (FLOAT)_width;
	vp.Height = (FLOAT)_height;
	vp.MinDepth = 0.0f;
	vp.MaxDepth = 1.0f;
	vp.TopLeftX = 0.0f;
	vp.TopLeftY = 0.0f;
	_context->RSSetViewports(1, &vp);
	
	_context->RSSetState(_rasterizer_state);
	
	_rendering_ok = true;
	
	{
		D3D11_MAPPED_SUBRESOURCE sub;
		if (_context->Map(_vertex_buffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &sub) != S_OK)
			_rendering_ok = false;
		
		_vertices = (DX11_Vertex*)(sub.pData);
	}
	
	{
		D3D11_MAPPED_SUBRESOURCE sub;
		if (_context->Map(_lines_buffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &sub) != S_OK)
			_rendering_ok = false;
		
		_lines = (DX11_Vertex*)(sub.pData);
	}
	
	{
		D3D11_MAPPED_SUBRESOURCE sub;
		if (_context->Map(_text_buffer, NULL, D3D11_MAP_WRITE_DISCARD, NULL, &sub) != S_OK)
			_rendering_ok = false;
		
		_points = (DX11_Vertex*)(sub.pData);
	}
	
	_vertex_count = 0;
	_line_count = 0;
	_point_count = 0;
}

void c_dx11_render::end_render() {
	{
		_context->Unmap(_vertex_buffer, NULL);
		_context->Unmap(_lines_buffer, NULL);
		_context->Unmap(_text_buffer, NULL);
	}
	
	{
		UINT stride = sizeof(DX11_Vertex);
		UINT offset = 0;
		
		_context->IASetVertexBuffers(0, 1, &_vertex_buffer, &stride, &offset);
		_context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
		_context->Draw(_vertex_count , 0);
		
		_context->IASetVertexBuffers(0, 1, &_lines_buffer, &stride, &offset);
		_context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);
		_context->Draw(_line_count , 0);
		
		_context->IASetVertexBuffers(0, 1, &_text_buffer, &stride, &offset);
		_context->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_POINTLIST);
		_context->Draw(_point_count, 0);
	}
}

void c_dx11_render::draw_rect_xxyy(float x0, float y0, float x1, float y1, int r, int g, int b) {
	if (_vertex_count >= VERTEX_SIZE - 6 - 1)
		return;
	
	float x0x = -1.0f + (2.0f * (x0 * _width_inv));
	float y0x = 1.0f - (2.0f * (y0 * _height_inv));
	float x1x = -1.0f + (2.0f * (x1 * _width_inv));
	float y1x = 1.0f - (2.0f * (y1 * _height_inv));
	
	float r2 = (float)(r) * CLR_MUL;
	float g2 = (float)(g) * CLR_MUL;
	float b2 = (float)(b) * CLR_MUL;
	
	int i = _vertex_count;
	
	_vertices[i].pos[0] = x0x;
	_vertices[i].pos[1] = y0x;
	_vertices[i].color[0] = r2;
	_vertices[i].color[1] = g2;
	_vertices[i].color[2] = b2;
	
	i = ++_vertex_count;
	
	_vertices[i].pos[0] = x1x;
	_vertices[i].pos[1] = y0x;
	_vertices[i].color[0] = r2;
	_vertices[i].color[1] = g2;
	_vertices[i].color[2] = b2;
	
	i = ++_vertex_count;
	
	_vertices[i].pos[0] = x0x;
	_vertices[i].pos[1] = y1x;
	_vertices[i].color[0] = r2;
	_vertices[i].color[1] = g2;
	_vertices[i].color[2] = b2;
	
	i = ++_vertex_count;
	
	_vertices[i].pos[0] = x1x;
	_vertices[i].pos[1] = y1x;
	_vertices[i].color[0] = r2;
	_vertices[i].color[1] = g2;
	_vertices[i].color[2] = b2;
	
	i = ++_vertex_count;
	
	_vertices[i].pos[0] = x0x;
	_vertices[i].pos[1] = y1x;
	_vertices[i].color[0] = r2;
	_vertices[i].color[1] = g2;
	_vertices[i].color[2] = b2;
	
	i = ++_vertex_count;
	
	_vertices[i].pos[0] = x1x;
	_vertices[i].pos[1] = y0x;
	_vertices[i].color[0] = r2;
	_vertices[i].color[1] = g2;
	_vertices[i].color[2] = b2;
	
	++_vertex_count;
}

void c_dx11_render::draw_line(float x0, float y0, float x1, float y1, int r, int g, int b) {
	int i = _line_count;
	
	float x0x = -1.0f + (2.0f * (x0 * _width_inv));
	float y0x = 1.0f - (2.0f * (y0 * _height_inv));
	float x1x = -1.0f + (2.0f * (x1 * _width_inv));
	float y1x = 1.0f - (2.0f * (y1 * _height_inv));
	
	float r2 = (float)(r) * CLR_MUL;
	float g2 = (float)(g) * CLR_MUL;
	float b2 = (float)(b) * CLR_MUL;
	
	_lines[i].pos[0] = x0x;
	_lines[i].pos[1] = y0x;
	_lines[i].color[0] = r2;
	_lines[i].color[1] = g2;
	_lines[i].color[2] = b2;
	
	i = ++_line_count;
	
	_lines[i].pos[0] = x1x;
	_lines[i].pos[1] = y1x;
	_lines[i].color[0] = r2;
	_lines[i].color[1] = g2;
	_lines[i].color[2] = b2;
	
	++_line_count;
}

void c_dx11_render::draw_text_point(float x, float y) {
	int i = _point_count;
	
	if (i > TEXT_POINTS_SIZE - 2)
		return;
	
	_points[i].pos[0] = -1.0f + (2.0f * (x * _width_inv));
	_points[i].pos[1] = 1.0f - (2.0f * (y * _height_inv));
	
	_points[i].color[0] = (float)(_text_r) * CLR_MUL;
	_points[i].color[1] = (float)(_text_g) * CLR_MUL;
	_points[i].color[2] = (float)(_text_b) * CLR_MUL;
	
	i += 1;
	
	if (_draw_text_outline) {
		_points[i].pos[0] = -1.0f + (2.0f * ((x + 1.0f) * _width_inv));
		_points[i].pos[1] = 1.0f - (2.0f * ((y + 1.0f) * _height_inv));
		
		_points[i].color[0] = 0.0f;
		_points[i].color[1] = 0.0f;
		_points[i].color[2] = 0.0f;
		
		i += 1;
	}
	
	_point_count = i;
}